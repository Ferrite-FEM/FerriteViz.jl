var documenterSearchIndex = {"docs":
[{"location":"api.html#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"On this page the docs of the provided functions are listed","category":"page"},{"location":"api.html","page":"API Reference","title":"API Reference","text":"FerriteViz.MakiePlotter\nFerriteViz.solutionplot\nFerriteViz.cellplot\nFerriteViz.wireframe\nFerriteViz.arrows\nFerriteViz.surface\nFerriteViz.elementinfo\nFerriteViz.ferriteviewer\nFerriteViz.update!\nFerriteViz.for_discretization\nFerriteViz.crinkle_clip!\nFerriteViz.crinkle_clip\nFerriteViz.ClipPlane","category":"page"},{"location":"api.html#FerriteViz.MakiePlotter","page":"API Reference","title":"FerriteViz.MakiePlotter","text":"MakiePlotter(dh::Ferrite.AbstractDofHandler, u::Vector)\nMakiePlotter(dh::Ferrite.AbstractDofHandler, u::Vector, topology::TOP) where {TOP<:Ferrite.AbstractTopology}\n\nBuilds a static triangulation of the underlying grid in dh.grid for rendering via Makie. The triangulation acts as a \"L2\" triangulation, i.e. each triangle node is doubled. For large 3D grids, prefer to use the second constructor if you have already a topology. Otherwise, it will be rebuilt which is time consuming.\n\n\n\n\n\n","category":"type"},{"location":"api.html#FerriteViz.solutionplot","page":"API Reference","title":"FerriteViz.solutionplot","text":"solutionplot(plotter::MakiePlotter; kwargs...)\nsolutionplot(dh::AbstractDofHandler, u::Vector; kwargs...)\nsolutionplot!(plotter::MakiePlotter; kwargs...)\nsolutionplot!(dh::AbstractDofHandler, u::Vector; kwargs...)\n\nSolutionplot produces the classical contour plot onto the finite element mesh. Most important keyword arguments are:\n\nfield::Symbol=:default representing the field which gets plotted, defaults to the first field in the dh.\ndeformation_field::Symbol=:default field that transforms the mesh by the given deformation, defaults to no deformation\nprocess::Function=postprocess function to construct nodal scalar values from a vector valued problem\ncolormap::Symbol=:cividis\ndeformation_scale=1.0\nshading=false\nscale_plot=false\ntransparent=false\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.cellplot","page":"API Reference","title":"FerriteViz.cellplot","text":"cellplot(plotter::MakiePlotter,σ::Vector{T}; kwargs...) where T\ncellplot!(plotter::MakiePlotter,σ::Vector{T}; kwargs...) where T\n\ncellplot plots constant scalar data on the cells of the finite element mesh. If T is not a number, the keyword argument process can be passed in order to reduce the elements of σ to a scalar.\n\nkeyword arguments are:\n\ndeformation_field::Symbol=:default field that transforms the mesh by the given deformation, defaults to no deformation\nprocess::Function=identity function to construct cell scalar values. Defaults to identity, i.e. scalar values.\ncolormap::Symbol=:cividis\ndeformation_scale=1.0\nshading=false\nscale_plot=false\ntransparent=false\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.wireframe","page":"API Reference","title":"FerriteViz.wireframe","text":"wireframe(plotter::MakiePlotter; kwargs...)\nwireframe(dh::AbstractDofHandler, u::Vector; kwargs...)\nwireframe(grid::AbstractGrid; kwargs...)\nwireframe!(plotter::MakiePlotter; kwargs...)\nwireframe!(dh::AbstractDofHandler, u::Vector; kwargs...)\nwireframe!(grid::AbstractGrid; kwargs...)\n\nPlots the finite element mesh, optionally labels it and transforms it if a suitable deformation_field is given.\n\nplotnodes::Bool=true plots the nodes as circles/spheres\nstrokewidth::Int=2 how thick faces/edges are drawn\ncolor::Symbol=theme(scene,:linecolor) color of the faces/edges and nodes\nmarkersize::Int=30 size of the nodes\ndeformation_field::Symbol=:default field that transforms the mesh by the given deformation, defaults to no deformation\ndeformation_scale::Number=1.0 scaling of the deformation\ncellsets=false Color cells based on their cellset association. If no cellset is found for a cell, the cell is marked blue.\nnodelables=false global node id labels\nnodelabelcolor=:darkblue\ncelllabels=false global cell id labels\ncelllabelcolor=:darkred\ntextsize::Int=15 size of the label's text\nvisible=true\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.arrows","page":"API Reference","title":"FerriteViz.arrows","text":"arrows(plotter::MakiePlotter; kwargs...)\narrows(dh::AbstractDofHandler, u::Vector; kwargs...)\narrows!(plotter::MakiePlotter; kwargs...)\narrows!(dh::AbstractDofHandler, u::Vector; kwargs...)\n\nAt every node position a arrows is drawn, where the arrow tip ends at the node. Only works in dim >=2. If a color is specified the arrows are unicolored. Otherwise the color corresponds to the magnitude, or any other scalar value based on the process function.\n\narrowsize = 0.08\nnormalize = true\nfield = :default\ncolor = :default\ncolormap = :cividis\nprocess=postprocess\nlengthscale = 1f0\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.surface","page":"API Reference","title":"FerriteViz.surface","text":"surface(plotter::MakiePlotter; kwargs...)\nsurface(dh::AbstractDofHandler, u::Vector; kwargs...)\nsurface!(plotter::MakiePlotter; kwargs...)\nsurface!(dh::AbstractDofHandler, u::Vector; kwargs...)\n\nUses the given field and plots the scalar values as a surface. If it's a vector valued problem, the nodal vector values are transformed to a scalar based on process which defaults to the magnitude. Only availble in dim=2.\n\nfield = :default\nprocess = postprocess\nscale_plot = false\nshading = false\ncolormap = :cividis\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.elementinfo","page":"API Reference","title":"FerriteViz.elementinfo","text":"elementinfo(ip::Interpolation; kwargs...)\nelementinfo(cell::AbstractCell; kwargs...)\nelementinfo(ip::Type{Interpolation}; kwargs...)\nelementinfo(cell::Type{AbstractCell}; kwargs...)\n\nplotnodes=true controls if nodes of element are plotted\nstrokewidth=2 strokwidth of faces/edges\ncolor=theme(scene, :linecolor)\nmarkersize=30 size of the nodes\ntextsize=60 textsize of node-, edges- and facelabels\nnodelabels=true switch that controls plotting of nodelabels\nnodelabelcolor=:darkred\nnodelabeloffset=(0.0,0.0) offset of the nodelabel text relative to its associated node\nfacelabels=true switch that controls plotting of facelabels\nfacelabelcolor=:darkgreen\nfacelabeloffset=(-40,0) offset of the facelabel text relative to its associated face middlepoint\nedgelabels=true switch that controls plotting of edgelabels\nedgelabelcolor=:darkblue\nedgelabeloffset=(-40,-40) offset of the edgelabel text relative to its associated edge middlepoint\nfont=\"Julia Mono\" font of the node-, edge-, and facelabels\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.ferriteviewer","page":"API Reference","title":"FerriteViz.ferriteviewer","text":"ferriteviewer(plotter::MakiePlotter)\nferriteviewer(plotter::MakiePlotter, u_history::Vector{Vector{T}}})\n\nConstructs a viewer with a solutionplot, Colorbar as well as sliders,toggles and menus to change the current view. If the second dispatch is called a timeslider is added, in order to step through a set of solutions obtained from a simulation.\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.update!","page":"API Reference","title":"FerriteViz.update!","text":"FerriteViz.update!(plotter::MakiePlotter, u::Vector)\n\nUpdates the Observable plotter.u and thereby, triggers the plot to update.\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.for_discretization","page":"API Reference","title":"FerriteViz.for_discretization","text":"Create a first order discretization w.r.t. a field and transfer the solution.\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.crinkle_clip!","page":"API Reference","title":"FerriteViz.crinkle_clip!","text":"crinkle_clip!(plotter::MakiePlotter{3}, decision_fun)\n\nCrinkle clip updates the visibility of the triangles, based on an implicit description of the clipping surface. Here decision_fun takes the grid and a cell index as input and returns whether the cell is visible or not. Note that chained calls to crinkle_clip! won't work.\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.crinkle_clip","page":"API Reference","title":"FerriteViz.crinkle_clip","text":"crinkle_clip(plotter::MakiePlotter{3}, decision_fun) -> MakiePlotter\n\nCrinkle clip generates a new plotter with updated visibility of the triangles. Non-mutating version of crinkle_clip!. Note that chained calls to crinkle_clip won't work.\n\n\n\n\n\n","category":"function"},{"location":"api.html#FerriteViz.ClipPlane","page":"API Reference","title":"FerriteViz.ClipPlane","text":"Clip plane described by the normal and its distance to the coordinate origin.\n\n\n\n\n\n","category":"type"},{"location":"atopics.html#Advanced-Topics","page":"Advanced Topics","title":"Advanced Topics","text":"","category":"section"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"import JSServe # hide\nJSServe.Page() # hide","category":"page"},{"location":"atopics.html#Gradient-field-visualization","page":"Advanced Topics","title":"Gradient field visualization","text":"","category":"section"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"FerriteViz also makes it easy to visualize gradient fields, like for example strain or stress fields. A common approach to visualize stresses and strains is to compute the L2 projection onto a H1 field and plot this. However, a big downside is that we loose the ability to investigate the jumps between elements, as they get smoothed out, hiding possible issues in the solution. Therefore, we provide the ability to interpolate the gradient into a piecewise discontinuous field via FerriteViz.interpolate_gradient_field. This function may be moved to Ferrite in the future.","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"In this quick example we show how to visualize strains and stresses side-by-side","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"using Ferrite\nimport FerriteViz\nusing FerriteViz: ε\nimport WGLMakie #activating the backend, switch to GLMakie or CairoMakie (for 2D) locally\n\ninclude(\"ferrite-examples/incompressible-elasticity.jl\") #defines dh_linear, dh_quadratic, u_linear, u_quadratic and mp\n\n(dh_linear_grad, u_linear_grad) = FerriteViz.interpolate_gradient_field(dh_linear, u_linear, :u)\n(dh_quadratic_grad, u_quadratic_grad) = FerriteViz.interpolate_gradient_field(dh_quadratic, u_quadratic, :u)\nplotter_linear = FerriteViz.MakiePlotter(dh_linear_grad, u_linear_grad)\nplotter_quadratic = FerriteViz.MakiePlotter(dh_quadratic_grad, u_quadratic_grad)\nσ(∇u) = 2*mp.G*dev(ε(∇u)) + mp.K*tr(ε(∇u))*ones(ε(∇u)) #helper function to map gradient to stress\ncmap = :jet\n\nf = WGLMakie.Figure()\naxs = [WGLMakie.Axis(f[1, 1], title=\"Strain norm (linear)\"),WGLMakie.Axis(f[1, 2], title=\"Stress norm (linear)\"),WGLMakie.Axis(f[1, 3], title=\"Pressure (deformed, linear)\"),\n       WGLMakie.Axis(f[3, 1], title=\"Strain norm (quadratic)\"),WGLMakie.Axis(f[3, 2], title=\"Stress norm (quadratic)\"),WGLMakie.Axis(f[3, 3], title=\"Pressure (deformed, quadratic)\")]\np1 = FerriteViz.solutionplot!(axs[1], plotter_linear, process=∇u->norm(ε(∇u)), colormap=cmap, field=:gradient)\np2 = FerriteViz.solutionplot!(axs[2], plotter_linear, process=∇u->norm(σ(∇u)), colormap=cmap, field=:gradient)\np3 = FerriteViz.solutionplot!(axs[3], dh_linear, u_linear, field=:p, deformation_field=:u, colormap=cmap)\nf[2,1] = WGLMakie.Colorbar(f[1,1], p1, vertical=false)\nf[2,2] = WGLMakie.Colorbar(f[1,2], p2, vertical=false)\nf[2,3] = WGLMakie.Colorbar(f[1,3], p3, vertical=false)\n\np4 = FerriteViz.solutionplot!(axs[4], plotter_quadratic, process=∇u->norm(ε(∇u)), colormap=cmap, field=:gradient)\np5 = FerriteViz.solutionplot!(axs[5], plotter_quadratic, process=∇u->norm(σ(∇u)), colormap=cmap, field=:gradient)\np6 = FerriteViz.solutionplot!(axs[6], dh_quadratic, u_quadratic, field=:p, deformation_field=:u, colormap=cmap)\nf[4,1] = WGLMakie.Colorbar(f[3,1], p1, vertical=false)\nf[4,2] = WGLMakie.Colorbar(f[3,2], p2, vertical=false)\nf[4,3] = WGLMakie.Colorbar(f[3,3], p3, vertical=false)\n\nf","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"An alternative to this approach is to compute gradient quantities at samples points and plot these via arrows.","category":"page"},{"location":"atopics.html#High-order-fields","page":"Advanced Topics","title":"High-order fields","text":"","category":"section"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"The investigation of high-order fields is currently only supported via a first-order refinment of the problem. Here, the high-order approximation is replaced by a first order approximation of the field, which is spanned by the nodes of the high-order approximation. For example, the first order refinement of a heat problem on a square domain for Lagrange polynomials of order 5 looks like this:","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"include(\"ferrite-examples/heat-equation.jl\"); #defines manufactured_heat_problem\n\nf = WGLMakie.Figure()\naxs = [WGLMakie.Axis3(f[1, 1], title=\"Coarse\"), WGLMakie.Axis3(f[1, 2], title=\"Fine\")]\n\ndh,u = manufactured_heat_problem(Triangle, Lagrange{2,RefTetrahedron,5}(), 1)\ndh_for,u_for = FerriteViz.for_discretization(dh, u)\nplotter_for = FerriteViz.MakiePlotter(dh_for, u_for)\nFerriteViz.surface!(axs[1], plotter_for)\n\ndh,u = manufactured_heat_problem(Triangle, Lagrange{2,RefTetrahedron,5}(), 3)\ndh_for,u_for = FerriteViz.for_discretization(dh, u)\nplotter_for = FerriteViz.MakiePlotter(dh_for, u_for)\nFerriteViz.surface!(axs[2], plotter_for)\n\nf","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"Note that this method produces small artifacts due to the flattening of the nonlinearities of the high order ansatz. However, it is still sufficient to investigate important features of the solution. In future we will also provide an adaptive tessellation algorithm to resolve the high-order fields with full detail.","category":"page"},{"location":"atopics.html#Live-plotting","page":"Advanced Topics","title":"Live plotting","text":"","category":"section"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"Plotting while a computational heavy simulation is performed can be easily achieved with FerriteViz.jl. Every plotter object of type MakiePlotter holds a property called u which is a so called Observable. If an Observable changes, all its dependencies are triggered to change as well. So, all we need to do is to update the observable plotter.u. For this purpose the function FerriteViz.update! is provided. It takes a plotter:MakiePlotter and a new solutiuon vector u_new and updates plotter.u, thereby all open plots called with plotter are updated.","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"A summary of the needed steps for live plotting:","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"Create a plotter before your time stepping begins\nCall a plot or the ferriteviewer and save the return in a variable, e.g. fig\ndisplay(fig) in order to force the plot/viewer to pop up, even if its called inside a function body\nFerriteViz.update!(plotter,u_new) where u_new corresponds to your new solution of the time step","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"As an illustrative example, let's consider a slightly modified plasticity example of Ferrite.jl. For the full source code, please refer to the link. In the following code we only highlight the necessary changes.","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"function solve(liveplotting=false)\n    # set up your problem\n    # lots of code\n    dh = create_dofhandler(grid, interpolation) #helper function from script file\n    n_dofs = ndofs(dh)  # total number of dofs\n    u  = zeros(n_dofs)\n\n    if liveplotting\n        ####### Here we take care of the conceptual steps 1, 2 and 3 #######\n        plotter = MakiePlotter(dh,u)\n        fig = ferriteviewer(plotter)\n        display(fig)\n        ####################################################################\n    end\n\n    Δu = zeros(n_dofs)  # displacement correction\n    r = zeros(n_dofs)   # residual\n    K = create_sparsity_pattern(dh); # tangent stiffness matrix\n\n    nqp = getnquadpoints(cellvalues)\n    states = [[MaterialState() for _ in 1:nqp] for _ in 1:getncells(grid)]\n\n    # Newton-Raphson loop\n    NEWTON_TOL = 1 # 1 N\n\n    for timestep in 1:n_timesteps\n        while true; newton_itr += 1\n\n            if newton_itr > 8\n                error(\"Reached maximum Newton iterations, aborting\")\n                break\n            end\n            K, r = doassemble(cellvalues, facevalues, K, grid, dh, material, u,\n                             states, traction);\n            norm_r = norm(r[Ferrite.free_dofs(dbcs)])\n\n            if norm_r < NEWTON_TOL\n                break\n            end\n\n            apply_zero!(K, r, dbcs)\n            Δu = Symmetric(K) \\ r\n            u -= Δu\n        end\n\n        if liveplotting\n            ####### Step 4 updating the current solution vector in plotter #######\n            FerriteViz.update!(plotter,u)\n            ######################################################################\n            sleep(0.1)\n        end\n\n        # Update all the material states after we have reached equilibrium\n        for cell_states in states\n            foreach(update_state!, cell_states)\n        end\n        u_max[timestep] = max(abs.(u)...) # maximum displacement in current timestep\n    end\n\n    # postprocessing\n    # lots of code\n    return u, dh, traction_magnitude\nend\n\nu, dh, traction_magnitude = solve();","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"Note that we create plotter::MakiePlotter object before the time stepping begins, as well as calling ferriteviewer on the plotter. The next function call is crucial to get the live plotting working. display(fig) forces the viewer to pop up, even if it's inside a function body. Now, the only missing piece is the FerriteViz.update! of the plotter, which happens directly after the Newton iteration. The result for this code looks like this:","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"(Image: liveplot)","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"Since the computational load of one time step is in this example too low, the plotter would just update all the time and likely never display something, so we artificially increase the load of one time step by sleeping for 0.1s.","category":"page"},{"location":"atopics.html","page":"Advanced Topics","title":"Advanced Topics","text":"If you don't need the full viewer as a live plot, you can of course call instead solutionplot (or any other plot/plot combination) with appropriate keyword arguments to only have a specific live plot. This can be beneficial performancewise.","category":"page"},{"location":"index.html#FerriteViz.jl","page":"Home","title":"FerriteViz.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"FerriteViz.jl is a small package to visualize your Ferrite.jl results. Currently all Makie backends are supported and thus, you can visualize your results in a GLMakie window, inside Pluto/Jupyter notebooks via WGLMakie and produce nice vector graphics with CairoMakie.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"In the future this package tries to adapt also other plotting packages, such as Plots.jl and PGFPlotsX.jl. Contributions are highly welcome.","category":"page"},{"location":"index.html#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Install FerriteViz.jl with the in-built package manager of Julia","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"pkg> add FerriteViz","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Do your computation with Ferrite.jl and save the used DofHandler and solution vector into a variable. Pass those two variables into the MakiePlotter constructor","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"plotter = MakiePlotter(dh,u)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Now, you can use solutionplot, wireframe, arrows, surface or the viewer via ferriteviewer.  Note that the mutating solutionplot!, wireframe!, arrows! and surface! are available as well.","category":"page"},{"location":"index.html#Unique-features","page":"Home","title":"Unique features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package offers a set of unique features that are not easily reproducible with other export options of Ferrite.jl:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"FerriteViz.solutionplot FE solution contour plot on arbitrary finite element mesh (in Makie called mesh plots)\nFerriteViz.ferriteviewer viewer with toggles and menus that update the plot\nFerriteViz.wireframe plots the finite element mesh and optionally labels nodes and cells\nFerriteViz.arrows - also called quiver plots, in paraview glyph filter\nFerriteViz.surface 2D solutions in 3D space as surface, in paraview warp by scalar filter\nsynchronous plotting while your simulation runs with any of the above listed options\nmutating versions of the above listed functions (except for the viewer)\ndeformed plots available for solutionplot and wireframe with linear geometry\nfull integration into the Makie ecosystem, e.g. themes, layouts etc. \nGPU powered plotting with GLMakie.jl, jupyter/pluto notebook plotting with WGLMakie.jl and vector graphics with CairoMakie.jl\nvisualization of high order solutions via first order refinement\nvisualization of non-conforming solutions, e.g. for Crouzeix-Raviart ansatz","category":"page"},{"location":"tutorial.html#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial.html#Solve-a-Boundary-Value-Problem","page":"Tutorial","title":"Solve a Boundary Value Problem","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Start with solving a boundary value problem as you would usually do with Ferrite. It is crucial that you safe your used DofHandler and solution vector because we need to pass those objects to MakiePlotter.","category":"page"},{"location":"tutorial.html#Basics","page":"Tutorial","title":"Basics","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"tip: Plotting Functions\nCurrently, FerriteViz.solutionplot, FerriteViz.wireframe, FerriteViz.surface, FerriteViz.arrows and their mutating analogues with ! are defined for MakiePlotter. Due to the nature of the documentation we need WGLMakie, however, you can simply exchange any WGLMakie call by GLMakie.","category":"page"},{"location":"tutorial.html#Mesh-utilities","page":"Tutorial","title":"Mesh utilities","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"import JSServe # hide\nJSServe.Page() # hide","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"You can start by plotting your mesh","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"import FerriteViz\nusing Ferrite\nimport WGLMakie #activating the backend, switch to GLMakie or CairoMakie (for 2D) locally\nWGLMakie.set_theme!(resolution=(800, 400)) # hide\n\ngrid = generate_grid(Hexahedron,(3,3,3))\nFerriteViz.wireframe(grid,markersize=10,strokewidth=2)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"FerriteViz.jl also supports showing labels for Ferrite.AbstractGrid entities, such as node- and celllabels, as well as plotting cellsets.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"grid = generate_grid(Quadrilateral,(3,3))\naddcellset!(grid,\"s1\",Set((1,4,7)))\naddcellset!(grid,\"s2\",Set((2,5,8)))\naddcellset!(grid,\"s3\",Set((3,6,9)))\nFerriteViz.wireframe(grid,markersize=10,strokewidth=1,nodelabels=true,celllabels=true,cellsets=true)","category":"page"},{"location":"tutorial.html#Solution-field-of-a-boundary-value-problem","page":"Tutorial","title":"Solution field of a boundary value problem","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"If you solve some boundary value problem with Ferrite.jl keep in mind to safe your dh::DofHandler and solution vector u::Vector{T} in some variable. With them, we create the MakiePlotter struct that dispatches on the plotting functions.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"include(\"ferrite-examples/incompressible-elasticity.jl\") #defines variables dh_quadratic and u_quadratic\n\nplotter = FerriteViz.MakiePlotter(dh_quadratic,u_quadratic)\nFerriteViz.arrows(plotter)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Per default, all plotting functions grab the first field in the DofHandler, but of course you can plot a different field as well. The next plot will show the pressure instead of the displacement","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"FerriteViz.solutionplot(plotter,field=:p)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"For certain 2D problems it makes sense to visualize the result as a surface plot. To showcase the combination with the mutating versions of the plotting functions, the solutionplot function is plotted below the surface plot","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"FerriteViz.surface(plotter)\nFerriteViz.solutionplot!(plotter,colormap=:magma)\nWGLMakie.current_figure()","category":"page"},{"location":"tutorial.html#Deformed-mesh-for-mechanical-boundary-value-problem","page":"Tutorial","title":"Deformed mesh for mechanical boundary value problem","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"However, in structural mechanics we often would like to see the deformed configuration, which can be achieved by providing a deformation_field::Symbol as a keyword argument.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"include(\"ferrite-examples/plasticity.jl\") #only defines solving function\nu, dh, uhistory, σ, κ = solve()\nplotter = FerriteViz.MakiePlotter(dh,u)\n\nFerriteViz.solutionplot(plotter,colormap=:thermal,deformation_field=:u)\nFerriteViz.wireframe!(plotter,deformation_field=:u,markersize=10,strokewidth=1)\nWGLMakie.current_figure()","category":"page"},{"location":"tutorial.html#Showing-per-cell-data","page":"Tutorial","title":"Showing per-cell data","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"FerriteViz.jl also supports to plot cell data, such as the averaged von-Mises stress or the drag stress of the plasticity example.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"u, dh, uhistory, σ, κ = solve()\nFerriteViz.cellplot(plotter,σ,colormap=:thermal,deformation_field=:u,deformation_scale=2.0)\nFerriteViz.wireframe!(plotter,deformation_field=:u,markersize=10,strokewidth=1,deformation_scale=2.0)\nWGLMakie.current_figure()","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"For a more granular investigation of the stress field consult the advanced tutorial.","category":"page"},{"location":"tutorial.html#Interior-of-a-3D-domain","page":"Tutorial","title":"Interior of a 3D domain","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"For 3D problems we can also inspect the interior of the domain. Currenly we only have crinkle clipping implemented and it can be used as follows:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"clip_plane = FerriteViz.ClipPlane(Vec((0.0,0.5,0.5)), 0.7)\nclipped_plotter = FerriteViz.crinkle_clip(plotter, clip_plane)\nFerriteViz.solutionplot(clipped_plotter,deformation_field=:u,colormap=:thermal,deformation_scale=2.0)\nWGLMakie.current_figure()","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Note that we can replace the plane withs some other object or a decision function. Such a function takes the grid and a cell index as input and returns a boolean which decides whether a cell is visible or not.","category":"page"},{"location":"tutorial.html#What's-next?","page":"Tutorial","title":"What's next?","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Further, this package provides an interactive viewer that you can call with ferriteviewer(plotter) and ferriteviewer(plotter,u_history) for time dependent views, respectively. If you want to live plot your solution while solving some finite element system, consider to take a look at the advanced topics page.","category":"page"}]
}
